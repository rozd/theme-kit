# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

ThemeKit is a Swift package for SwiftUI that provides:
1. **Core theming types** — backbone types that implement environment-aware theming (ThemeAdaptiveStyle, Codable conformances)
2. **A code generation command plugin** — reads a `theme.json` config and generates all concrete theme files (Theme, ThemeShapeStyle, ThemeColors, ThemeGradients, etc.)

The theming approach is described in detail at: https://dev.to/rozd/building-a-native-feeling-theme-system-in-swiftui-h1k

## Build & Test Commands

```bash
swift build                          # Build the package
swift test                           # Run all tests
swift test --filter <TestCase>       # Run a single test class
swift test --filter <TestCase>/<method>  # Run a single test method
swift package plugin <command-name>  # Run the command plugin locally
```

## Architecture

### Package Targets

```
Sources/
  ThemeKit/              — Core types (library, what app devs import)
  ThemeKitGenerator/     — Generation logic (library, testable)
  ThemeKitGeneratorCLI/  — CLI executable wrapping the generator (invoked by plugin)
Plugins/
  ThemeKitPlugin/        — Thin command plugin entry point
Tests/
  ThemeKitTests/         — Core type tests (with stub generated types)
  ThemeKitGeneratorTests/ — Generation logic tests
```

### Core Types (ThemeKit target)

- **`ThemeAdaptiveStyle<Style>`** — Generic wrapper that pairs optional `Defaults` (the serializable data) with a `Resolver` (a closure that reads `EnvironmentValues`). `Defaults` is a nested enum with three cases: `.colorScheme(light:dark:)`, `.sizeClass(compact:regular:)`, and `.value(_:)`. Each case knows how to create its own resolver. Styles created with a custom `Resolver` have `defaults = nil` and cannot be encoded. Convenience computed properties `.light`, `.dark`, `.compact`, `.regular` extract values from the matching `Defaults` case (returning `nil` for mismatched cases).
- **Codable conformances** — `Color`, `Gradient`, etc. get `Codable` conformance (via `@retroactive`) for remote/serialized theming.

### Generated Types (NOT in the package — produced per app)

Everything else is generated by the plugin into the app dev's project:
- **`ThemeShapeStyle<Style>`** — `ShapeStyle` that resolves via `KeyPath<Theme, ThemeAdaptiveStyle<Style>>` against theme + color scheme from `EnvironmentValues`. References generated `Theme` type, so must be generated.
- **`ThemeShadowedStyle<Base>`** — Composing wrapper that pairs any `ShapeStyle` with a shadow keypath. Only generated when shadows category is present in config. Enables `.surface.cardShadow` chaining.
- **`Theme`** — Root container, only includes categories present in config.
- **`ThemeColors`**, **`ThemeGradients`**, **`ThemeShadows`**, etc. — Structs with `let` properties per token.
- **`*+CopyWith.swift`** — Immutable update extensions for each struct.
- **`ShapeStyle+*.swift`** — Convenience static properties on `ShapeStyle`. Shadow extensions also include unconstrained instance properties for composition (e.g. `.surface.cardShadow`).
- **`Environment+Theme.swift`** — `EnvironmentValues.theme` entry (always the same content).

App devs are responsible for creating `Theme+Default.swift` with a `static let default` providing actual style values.

### Generator (ThemeKitGenerator target)

Pure functions: config in, Swift source strings out. Templates are embedded as Swift string literals (not separate files) since they're small and the dynamic parts are simple loops over token names. No external template engine.

### Config Format

JSON file (`theme.json`) with a JSON Schema at `theme.schema.json` in the repo root. Token entries are either plain strings or objects with a `style` override:

```json
{
  "colors": ["surface", { "name": "primary", "style": "primaryColor" }],
  "gradients": ["primary"]
}
```

- String `"surface"` → struct property `surface`, ShapeStyle `.surface`
- Object `{ "name": "primary", "style": "primaryColor" }` → struct property `primary`, ShapeStyle `.primaryColor` (avoids conflicts with SwiftUI built-ins)

Only categories present in config are included in generated `Theme` struct.

The config model (`ThemeToken`) is a struct with `name` and `style` properties and custom `Codable` — strings decode to both fields equal, objects require both keys. Encoding round-trips: equal name/style encodes as string.

### Configurator Web App

A Svelte SPA at `.github/pages/` that lets users build `theme.json` visually instead of editing JSON by hand. Deployed to GitHub Pages (`https://rozd.github.io/theme-kit/`) via `.github/workflows/deploy-pages.yml`. Fetches the JSON Schema at runtime to drive the UI — categories, token fields, and config options are all derived from `theme.schema.json`.

## Key Patterns

- All types are `nonisolated`, `Sendable`, and `Codable`
- Style resolution goes through SwiftUI's `resolve(in: EnvironmentValues)` — never requires `@Environment` in views
- Tokens adapt by axis: colorScheme (light/dark), sizeClass (compact/regular), or constant value — the `Defaults` enum case determines which
- Codable auto-detects format by JSON keys: `{"light","dark"}` → colorScheme, `{"compact","regular"}` → sizeClass, plain value → value
- `copyWith` pattern enables immutable theme updates at runtime
- Generated `ShapeStyle` extensions constrain `Self` to `ThemeShapeStyle<ConcreteType>`
- Shadow tokens also generate unconstrained instance properties on `ShapeStyle` for composition — static and instance properties coexist without conflict
- Test targets use stub implementations of generated types for testing core types
