import Testing
import SwiftUI
import Foundation
@testable import ThemeKit

@Suite("MeshGradient+Codable")
struct MeshGradientCodableTests {

    // MARK: - Helpers

    private func jsonRoundTrip(_ value: MeshGradient) throws -> MeshGradient {
        let data = try JSONEncoder().encode(value)
        return try JSONDecoder().decode(MeshGradient.self, from: data)
    }

    private func jsonEncode(_ value: MeshGradient) throws -> [String: Any] {
        let data = try JSONEncoder().encode(value)
        return try #require(try JSONSerialization.jsonObject(with: data) as? [String: Any])
    }

    // MARK: - Decoding

    @Test func decode_withAutoGeneratedPoints() throws {
        let json = Data("""
        {
            "width": 2,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"]
        }
        """.utf8)
        let mesh = try JSONDecoder().decode(MeshGradient.self, from: json)
        #expect(mesh.width == 2)
        #expect(mesh.height == 2)
    }

    @Test func decode_withExplicitPoints() throws {
        let json = Data("""
        {
            "width": 2,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"],
            "points": [[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0]]
        }
        """.utf8)
        let mesh = try JSONDecoder().decode(MeshGradient.self, from: json)
        #expect(mesh.width == 2)
        #expect(mesh.height == 2)
    }

    @Test func decode_3x2_setsCorrectDimensions() throws {
        let json = Data("""
        {
            "width": 3,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#00FFFF", "#FFFFFF"]
        }
        """.utf8)
        let mesh = try JSONDecoder().decode(MeshGradient.self, from: json)
        #expect(mesh.width == 3)
        #expect(mesh.height == 2)
    }

    @Test func decode_missingColors_throws() {
        let json = Data("""
        { "width": 2, "height": 2 }
        """.utf8)
        #expect(throws: DecodingError.self) {
            _ = try JSONDecoder().decode(MeshGradient.self, from: json)
        }
    }

    @Test func decode_missingWidth_throws() {
        let json = Data("""
        { "height": 2, "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"] }
        """.utf8)
        #expect(throws: DecodingError.self) {
            _ = try JSONDecoder().decode(MeshGradient.self, from: json)
        }
    }

    @Test func decode_missingHeight_throws() {
        let json = Data("""
        { "width": 2, "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"] }
        """.utf8)
        #expect(throws: DecodingError.self) {
            _ = try JSONDecoder().decode(MeshGradient.self, from: json)
        }
    }

    // MARK: - Encoding

    @Test func encode_producesAllExpectedKeys() throws {
        let json = Data("""
        {
            "width": 2,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"]
        }
        """.utf8)
        let mesh = try JSONDecoder().decode(MeshGradient.self, from: json)
        let encoded = try jsonEncode(mesh)

        #expect(encoded["width"] as? Int == 2)
        #expect(encoded["height"] as? Int == 2)
        #expect(encoded["colors"] != nil)
        #expect(encoded["points"] != nil)
    }

    @Test func encode_colorsAreHexStrings() throws {
        let json = Data("""
        {
            "width": 2,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"]
        }
        """.utf8)
        let mesh = try JSONDecoder().decode(MeshGradient.self, from: json)
        let encoded = try jsonEncode(mesh)
        let colors = try #require(encoded["colors"] as? [String])

        #expect(colors.count == 4)
        #expect(colors[0] == "#FF0000")
        #expect(colors[1] == "#00FF00")
        #expect(colors[2] == "#0000FF")
        #expect(colors[3] == "#FFFFFF")
    }

    @Test func encode_pointsAreFloat2Arrays() throws {
        let json = Data("""
        {
            "width": 2,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"]
        }
        """.utf8)
        let mesh = try JSONDecoder().decode(MeshGradient.self, from: json)
        let encoded = try jsonEncode(mesh)
        let points = try #require(encoded["points"] as? [[NSNumber]])

        #expect(points.count == 4)
        // top-left
        #expect(points[0][0].floatValue == 0.0)
        #expect(points[0][1].floatValue == 0.0)
        // top-right
        #expect(points[1][0].floatValue == 1.0)
        #expect(points[1][1].floatValue == 0.0)
    }

    // MARK: - Round-trips

    @Test func roundTrip_preservesDimensions() throws {
        let json = Data("""
        {
            "width": 3,
            "height": 3,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#00FFFF", "#800080", "#FFFFFF", "#808080", "#000000"]
        }
        """.utf8)
        let original = try JSONDecoder().decode(MeshGradient.self, from: json)
        let decoded = try jsonRoundTrip(original)
        #expect(decoded.width == 3)
        #expect(decoded.height == 3)
    }

    @Test func roundTrip_preservesColorCount() throws {
        let json = Data("""
        {
            "width": 2,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"]
        }
        """.utf8)
        let original = try JSONDecoder().decode(MeshGradient.self, from: json)
        let encoded = try jsonEncode(original)
        let colors = try #require(encoded["colors"] as? [String])
        #expect(colors.count == 4)
    }

    @Test func roundTrip_preservesColorValues() throws {
        let json = Data("""
        {
            "width": 2,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"]
        }
        """.utf8)
        let original = try JSONDecoder().decode(MeshGradient.self, from: json)
        let data = try JSONEncoder().encode(original)
        let reDecoded = try JSONSerialization.jsonObject(with: data) as! [String: Any]
        let colors = reDecoded["colors"] as! [String]

        #expect(colors[0] == "#FF0000")
        #expect(colors[1] == "#00FF00")
        #expect(colors[2] == "#0000FF")
        #expect(colors[3] == "#FFFFFF")
    }

    @Test func roundTrip_preservesPointCount() throws {
        let json = Data("""
        {
            "width": 2,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"]
        }
        """.utf8)
        let original = try JSONDecoder().decode(MeshGradient.self, from: json)
        let encoded = try jsonEncode(original)
        let points = try #require(encoded["points"] as? [[NSNumber]])
        #expect(points.count == 4)
    }

    @Test func roundTrip_withExplicitPoints_preservesPoints() throws {
        let json = Data("""
        {
            "width": 2,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"],
            "points": [[0.0, 0.0], [0.8, 0.0], [0.2, 1.0], [1.0, 1.0]]
        }
        """.utf8)
        let original = try JSONDecoder().decode(MeshGradient.self, from: json)
        let encoded = try jsonEncode(original)
        let points = try #require(encoded["points"] as? [[NSNumber]])

        // Non-uniform points should survive the round-trip
        #expect(points[1][0].floatValue == Float(0.8))
        #expect(points[2][0].floatValue == Float(0.2))
    }

    @Test func roundTrip_encodeDecodeEncode_stableJSON() throws {
        let json = Data("""
        {
            "width": 2,
            "height": 2,
            "colors": ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"]
        }
        """.utf8)
        let first = try JSONDecoder().decode(MeshGradient.self, from: json)
        let firstData = try JSONEncoder().encode(first)
        let second = try JSONDecoder().decode(MeshGradient.self, from: firstData)
        let secondData = try JSONEncoder().encode(second)

        let firstJSON = try JSONSerialization.jsonObject(with: firstData) as! [String: Any]
        let secondJSON = try JSONSerialization.jsonObject(with: secondData) as! [String: Any]

        #expect(firstJSON["width"] as? Int == secondJSON["width"] as? Int)
        #expect(firstJSON["height"] as? Int == secondJSON["height"] as? Int)
        #expect((firstJSON["colors"] as? [String]) == (secondJSON["colors"] as? [String]))
    }

    // MARK: - Convenience init encoding

    @Test func convenienceInit_encodesCorrectStructure() throws {
        let mesh = MeshGradient(
            width: 2,
            height: 2,
            colors: [Color(hex: 0xFF0000), Color(hex: 0x00FF00), Color(hex: 0x0000FF), Color(hex: 0xFFFFFF)]
        )
        let encoded = try jsonEncode(mesh)

        #expect(encoded["width"] as? Int == 2)
        #expect(encoded["height"] as? Int == 2)

        let colors = try #require(encoded["colors"] as? [String])
        #expect(colors == ["#FF0000", "#00FF00", "#0000FF", "#FFFFFF"])

        let points = try #require(encoded["points"] as? [[NSNumber]])
        #expect(points.count == 4)
    }

    @Test func convenienceInit_roundTrips() throws {
        let original = MeshGradient(
            width: 2,
            height: 2,
            colors: [Color(hex: 0xFF0000), Color(hex: 0x00FF00), Color(hex: 0x0000FF), Color(hex: 0xFFFFFF)]
        )
        let decoded = try jsonRoundTrip(original)
        #expect(decoded.width == original.width)
        #expect(decoded.height == original.height)
    }

    @Test func convenienceInit_3x2_roundTripsWithCorrectPointCount() throws {
        let mesh = MeshGradient(
            width: 3,
            height: 2,
            colors: [
                Color(hex: 0xFF0000), Color(hex: 0x00FF00), Color(hex: 0x0000FF),
                Color(hex: 0xFFFF00), Color(hex: 0x00FFFF), Color(hex: 0xFFFFFF),
            ]
        )
        let encoded = try jsonEncode(mesh)
        let points = try #require(encoded["points"] as? [[NSNumber]])
        #expect(points.count == 6)
        let colors = try #require(encoded["colors"] as? [String])
        #expect(colors.count == 6)
    }

    // MARK: - Bezier points encoding

    @Test func encode_bezierPoints_encodesPositions() throws {
        let p = SIMD2<Float>(0, 0) // placeholder control point
        let bezierPts: [MeshGradient.BezierPoint] = [
            .init(position: .init(0.0, 0.0), leadingControlPoint: p, topControlPoint: p, trailingControlPoint: p, bottomControlPoint: p),
            .init(position: .init(1.0, 0.0), leadingControlPoint: p, topControlPoint: p, trailingControlPoint: p, bottomControlPoint: p),
            .init(position: .init(0.0, 1.0), leadingControlPoint: p, topControlPoint: p, trailingControlPoint: p, bottomControlPoint: p),
            .init(position: .init(1.0, 1.0), leadingControlPoint: p, topControlPoint: p, trailingControlPoint: p, bottomControlPoint: p),
        ]
        let mesh = MeshGradient(
            width: 2,
            height: 2,
            bezierPoints: bezierPts,
            colors: [Color(hex: 0xFF0000), Color(hex: 0x00FF00), Color(hex: 0x0000FF), Color(hex: 0xFFFFFF)]
        )
        let encoded = try jsonEncode(mesh)

        let points = try #require(encoded["points"] as? [[NSNumber]])
        #expect(points.count == 4)
        #expect(points[0][0].floatValue == 0.0)
        #expect(points[0][1].floatValue == 0.0)
        #expect(points[3][0].floatValue == 1.0)
        #expect(points[3][1].floatValue == 1.0)
    }

    @Test func encode_bezierPoints_discardsControlPoints() throws {
        let bezierPts: [MeshGradient.BezierPoint] = [
            .init(position: .init(0.0, 0.0), leadingControlPoint: .init(-0.1, -0.1), topControlPoint: .init(0.0, -0.1), trailingControlPoint: .init(0.1, 0.0), bottomControlPoint: .init(0.0, 0.1)),
            .init(position: .init(1.0, 0.0), leadingControlPoint: .init(0.9, 0.0), topControlPoint: .init(1.0, -0.1), trailingControlPoint: .init(1.1, 0.0), bottomControlPoint: .init(1.0, 0.1)),
            .init(position: .init(0.0, 1.0), leadingControlPoint: .init(-0.1, 1.0), topControlPoint: .init(0.0, 0.9), trailingControlPoint: .init(0.1, 1.0), bottomControlPoint: .init(0.0, 1.1)),
            .init(position: .init(1.0, 1.0), leadingControlPoint: .init(0.9, 1.0), topControlPoint: .init(1.0, 0.9), trailingControlPoint: .init(1.1, 1.0), bottomControlPoint: .init(1.0, 1.1)),
        ]
        let mesh = MeshGradient(
            width: 2,
            height: 2,
            bezierPoints: bezierPts,
            colors: [Color(hex: 0xFF0000), Color(hex: 0x00FF00), Color(hex: 0x0000FF), Color(hex: 0xFFFFFF)]
        )
        let encoded = try jsonEncode(mesh)

        // Only positions survive; control points are discarded
        let points = try #require(encoded["points"] as? [[NSNumber]])
        #expect(points.count == 4)
        // Each point should have exactly 2 components (x, y), not control point data
        for point in points {
            #expect(point.count == 2)
        }
        #expect(points[0][0].floatValue == 0.0)
        #expect(points[1][0].floatValue == 1.0)
    }

    // MARK: - Point grid generation

    @Test func convenienceInit_producesCorrectPointGrid() {
        let points = MeshGradient.pointsFrom(width: 3, height: 2)
        // 3×2 grid = 6 points
        #expect(points.count == 6)
        // First point: top-left (0,0)
        #expect(points[0] == SIMD2<Float>(0.0, 0.0))
        // Last point: bottom-right (1,1)
        #expect(points[5] == SIMD2<Float>(1.0, 1.0))
        // Middle of first row: (0.5, 0)
        #expect(points[1] == SIMD2<Float>(0.5, 0.0))
    }

    @Test func convenienceInit_2x2_producesFourCornerPoints() {
        let points = MeshGradient.pointsFrom(width: 2, height: 2)
        #expect(points.count == 4)
        #expect(points[0] == SIMD2<Float>(0.0, 0.0))
        #expect(points[1] == SIMD2<Float>(1.0, 0.0))
        #expect(points[2] == SIMD2<Float>(0.0, 1.0))
        #expect(points[3] == SIMD2<Float>(1.0, 1.0))
    }

    @Test func convenienceInit_3x3_producesInteriorPoints() {
        let points = MeshGradient.pointsFrom(width: 3, height: 3)
        #expect(points.count == 9)
        // Center point at (0.5, 0.5)
        #expect(points[4] == SIMD2<Float>(0.5, 0.5))
        // Mid-top at (0.5, 0)
        #expect(points[1] == SIMD2<Float>(0.5, 0.0))
        // Mid-left at (0, 0.5)
        #expect(points[3] == SIMD2<Float>(0.0, 0.5))
    }

    @Test func convenienceInit_1x1_producesSingleOriginPoint() {
        // Edge case: 1×1 grid has a single point, but (0/0, 0/0) is NaN;
        // the implementation divides by (width-1) which is 0. Verify behavior.
        let points = MeshGradient.pointsFrom(width: 1, height: 1)
        #expect(points.count == 1)
        let point = points[0]
        // The single point should be at the origin and have finite coordinates.
        #expect(point == SIMD2<Float>(0.0, 0.0))
        #expect(point.x.isFinite && point.y.isFinite)
    }

    // MARK: - Invalid dimension handling

    @Test func convenienceInit_zeroWidth_returnsEmptyPointGrid() {
        let points = MeshGradient.pointsFrom(width: 0, height: 3)
        #expect(points.isEmpty)
    }

    @Test func convenienceInit_zeroHeight_returnsEmptyPointGrid() {
        let points = MeshGradient.pointsFrom(width: 3, height: 0)
        #expect(points.isEmpty)
    }

    @Test func convenienceInit_negativeWidth_returnsEmptyPointGrid() {
        let points = MeshGradient.pointsFrom(width: -1, height: 3)
        #expect(points.isEmpty)
    }

    @Test func convenienceInit_negativeHeight_returnsEmptyPointGrid() {
        let points = MeshGradient.pointsFrom(width: 3, height: -1)
        #expect(points.isEmpty)
    }
}
